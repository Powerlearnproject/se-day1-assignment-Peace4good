[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15768527&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Answer:  Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications. Software engineers apply engineering principles and knowledge of programming languages to build software solutions for end users.
The importance of software engineering lies in the fact that a specific piece of Software is required in almost every industry, every business, and purpose for the following reasons listed below:
1.	To Reduces Complexity
2.	Handle Big Projects
3.	To Minimize Software costs
4.	To decrease time
5.	Effectiveness
6.	Reliability


Identify and describe at least three key milestones in the evolution of software engineering.

Answer:  Software engineering is a relatively young discipline, but its roots can be traced back to the early days of computing. The field has evolved dramatically over time, with new challenges and opportunities emerging at each stage.

Early Days (1940s-1960s)

The first computers were massive and expensive, and programming them was a complex and labor-intensive task. Early programmers often had to write machine code, which is a low-level language that directly controls the computer's hardware.

Key milestones:

1948: Grace Hopper develops the first compiler, which translates human-readable code into machine code.
1957: FORTRAN, the first high-level programming language, is released.
1960s: The term "software engineering" is coined.
Challenges:
Programs were difficult to write and debug.
There were few tools and techniques available to help developers.
The field lacked a formal body of knowledge


List and briefly explain the phases of the Software Development Life Cycle.

Answer: A full SDLC has 7 basic stages: 
1.	Planning
2.	 Requirements
3.	 design and prototype
4.	 software development
5.	 Testing
6.	 Deployment
7.	 maintenance. 
1. Planning: In this phase, the project leads to defining the project’s purpose and the desired result. If the team is developing for a customer instead of to market, the project manager meets with them to discuss the product, its purpose, and the results they want to achieve. The team gathers as much information about the product from the customer. By the end of the planning phase, the team leads should have a working estimate of how much the project will cost and who will be part of the project. They also set a project deadline and milestones and overall create the basic structure for the project.
2. Requirements: This second phase of the software development life cycle is often done concurrently with the first. Here, the project lead analyzes the product or client’s goals and decides on the features to aim for as a final goal. Defining and establishing requirements determines what the application will do once launched, the necessary components, and the resources needed to launch it. 
3. Design and Prototype: Once phases 1 and 2 are understood and established, developers can start designing the software. The design phase defines how a software application will work. During this phase, teams decide on the programming language, screen layouts, and relevant documentation they will use. A prototype is a basic idea of how the application looks and works. 
4. Software Development: During this phase, developers start programming. If they work on a small project, one developer takes over the coding tasks, while on large projects, the codebase might be worked on by several developers. . In this phase, developers start building the entire system and shaping the project.

5. Testing: Testing happens in parallel with development, as developers write and test the code they’ve produced before moving on to the next coding task.
During this phase, different types of testing occur, such as code quality, unit testing, integration testing, performance testing, and security testing. 
6. Deployment: The deployment process starts once the testing phase is over and there are no bugs or errors in the development backlog. 
The team ensures that the software is up-to-date and secure enough for users and pushes it from the development environment to a live environment–usually an app store.
7. Maintenance: At this point the application is successfully launched and being used. Yet this last phase is still important because bugs or errors missed during testing are bound to appear. Simultaneously, by studying user behavior and feedback, the team can start to think about and plan for upgrades.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Answer: Agile and Waterfall are two popular methods for organizing projects. The main difference between Waterfall and Agile is:
•	Waterfall is a more traditional approach to project management, involving a linear flow.
•	Agile, on the other hand, embraces an iterative process. It involves rapid actions and great flexibility.
Example	Framework	Application	Outcome
Tech startup developing a mobile app	Agile	Uses iterative sprints to develop core functionalities and adds user feedback regularly	App evolves quickly with new features based on user needs, maintaining competitiveness in the market
Government software for public records	Waterfall	Follows a strict sequence from requirements gathering to maintenance, with no overlap between phases	Delivers a system that meets fixed requirements and regulations, with predictability and adherence to standards


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software Developer
Software developers are the builders of the software system.
They write, test, and maintain code to create software solutions based on the project’s specifications.
Software developers also collaborate with the software architect to ensure the project runs smoothly.
Tasks and Responsibilities:
•	Write clean, efficient, and maintainable code.
•	Debug and resolve software defects.
•	Collaborate with cross-functional teams.
•	Stay updated on industry trends.
Required Skills and Experience:
•	Proficiency in relevant programming languages.
•	Advanced coding skills.
•	Problem-solving and critical-thinking skills.
•	Ability to work in a team environment.
2. Quality Assurance Engineer
Quality Assurance (QA) specialists oversee the entire testing process, ensuring that software meets quality standards.
They work with the development team to ensure that the software system is thoroughly tested and free of defects.
Tasks and Responsibilities:
•	Develop and implement QA processes.
•	Perform automated and manual testing.
•	Monitor and improve testing efficiency.
•	Collaborate with teams to address quality concerns.
Required Skills and Experience:
•	Proficiency in testing tools and frameworks.
•	Analytical and problem-solving skills.
•	Knowledge of quality assurance best practices.
3. Project Manager
Project managers are the glue that holds the software development team together.
They typically work with product owners, business analysts, developers, and other team members.
Overseeing the entire development process, project managers ensure that software projects are completed on time and within budget.
Tasks and Responsibilities:
•	Develop project plans and timelines.
•	Allocate resources and manage budgets.
•	Monitor progress and address issues.
•	Communicate with stakeholders and keep them informed of the project’s progress.
Required Skills and Experience:
•	Exceptional organizational and leadership skills.
•	Proficiency in project management tools.
•	Experience managing software development projects.
•	Some level of technical knowledge.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Answer: You can use any text editor to write code. However, most integrated development environments (IDEs) include functionality that goes beyond text editing. They provide a central interface for common developer tools, making the software development process much more efficient. Developers can start programming new applications quickly instead of manually integrating and configuring different software. They also don't have to learn about all the tools and can instead focus on just one application. Integrated development environments (IDEs) can be broadly classified into several different categories, depending on the application development they support and how they work. However, many IDE software applications can fit into multiple categories. The following are some types of IDEs:
Local IDEs
Developers install and run local IDEs directly on their local machines. They also have to download and install various additional libraries depending on their coding preferences, project requirements, and development language. While local IDEs are customizable and do not require an internet connection once installed, they present several challenges:
•	They can be time consuming and difficult to set up.
•	They consume local machine resources and can slow down machine performance significantly.
•	Configuration differences between the local machine and the production environment can give rise to software errors.
Cloud IDEs
Developers use cloud IDEs to write, edit, and compile code directly in the browser so that they don't need to download software on their local machines. Cloud-based IDEs have several advantages over traditional IDEs. 
Version control software is a best practice for high performing software and DevOps teams. Version control also helps developers move faster and allows software teams to preserve efficiency and agility as the team scales to include more developers.

Version Control Systems (VCS) have seen great improvements over the past few decades and some are better than others. VCS are sometimes known as SCM (Source Code Management) tools or RCS (Revision Control System). One of the most popular VCS tools in use today is called Git. Git is a Distributed VCS, a category known as DVCS, more on that later. Like many of the most popular VCS systems available today, Git is free and open source. Regardless of what they are called, or which system is used, the primary benefits you should expect from version control are as follows.

1. A complete long-term change history of every file. This means every change made by many individuals over the years. Changes include the creation and deletion of files as well as edits to their contents. Different VCS tools differ on how well they handle renaming and moving of files. This history should also include the author, date and written notes on the purpose of each change. Having the complete history enables going back to previous versions to help in root cause analysis for bugs and it is crucial when needing to fix problems in older versions of software. If the software is being actively worked on, almost everything can be considered an "older version" of the software.

2. Branching and merging. Having team members work concurrently is a no-brainer, but even individuals working on their own can benefit from the ability to work on independent streams of changes. Creating a "branch" in VCS tools keeps multiple streams of work independent from each other while also providing the facility to merge that work back together, enabling developers to verify that the changes on each branch do not conflict. Many software teams adopt a practice of branching for each feature or perhaps branching for each release, or both. There are many different workflows that teams can choose from when they decide how to make use of branching and merging facilities in VCS.

3. Traceability. Being able to trace each change made to the software and connect it to project management and bug tracking software such as Jira, and being able to annotate each change with a message describing the purpose and intent of the change can help not only with root cause analysis and other forensics. Having the annotated history of the code at your fingertips when you are reading the code, trying to understand what it is doing and why it is so designed can enable developers to make correct and harmonious changes that are in accord with the intended long-term design of the system. This can be especially important for working effectively with legacy code and is crucial in enabling developers to estimate future work with any accuracy.

While it is possible to develop software without using any version control, doing so subjects the project to a huge risk that no professional team would be advised to accept. So the question is not whether to use version control but which version control system to use.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Answer:  1. Lack of Workflow Visibility
You can’t fully control the external events that impact your software development. But you can be in complete control of the internal factors and prepare your team to be highly resilient and respond to all sorts of challenges. 

A lot of development teams suffer because of a vague understanding of the engineering processes within their organization. Many don’t have clarity about the status of the projects, the activities and challenges of the individuals, and whatnot. 

All these stem from ineffective communication, lack of effective team collaboration, and broken SDLC processes. The domino effect of this is detrimental to your engineering efficiency, and the overall success of the organization. 

Lack of visibility is a critical software engineering challenge. Fail to acknowledge the visibility issue or brush it aside, and in no time your team may get beset by a plethora of business and software engineering challenges that sprout due to lack of visibility:

Misalignment between business goals & tech effort
Technical debt
Delayed projects & increased costs
Inefficient resource allocation & utilization
Software performance challenges
Siloed communication
Unproductive developers and engineering teams
Software security vulnerabilities
Upset stakeholders
How to Combat Lack of Visibility in Development Teams? 
Invest in tools that empower your teams to make data-driven decisions: 

Project management tools
Engineering analytics tools
Observability & monitoring tools
For instance, project managers can estimate timelines that are evidence-based and feasible. Engineering managers can evenly allocate work to software engineers based on individual capacity, workload, and expertise. Thus, saving your champions from the dreaded burnout while optimally utilizing their talent.

On another note, an engineering management platform like Hatica works by integrating with your existing tools stack using Connectors (Git, Jira, Slack, Pagerduty, Circle CI, etc.), pulls data from it, processes it, and serves you with actionable and visual engineering dashboards rich with metrics & insights gained from the mulled data. 

It helps in 360 degree visualization of both your health, and depth of engineering systems, so you can unearth blockers that are currently reducing the effectiveness of your engineering team.

Meanwhile, a metric-driven culture helps senior executives to measure the impact of engineering work, and even help bring alignment to teams crippled with lack of visibility, and communication debt.

We’ve comprehensively covered how cycle time, maker time, deployment velocity, change failure rate, and other key engineering metrics improve engineering visibility, and empower engineering managers to be more effective. 

2. Broken SDLC Processes
Your software development processes can be broken at multiple levels. It could be any of the following-

Poor requirement gathering
Scope creep
Code smells
Improper code reviews
Unhelpful documentation
Inefficient CI/CD pipelines
Inadequate testing or test coverage
Ineffective observability & monitoring
Lack of compliance & regulatory alignment 
Poor crisis response operating procedures, etcetera.
How to Improve Your SDLC Process? 
These are execution challenges that cripple many engineering teams. These software engineering challenges creep in when you do not define processes/procedures. Lack of documentation and training could also be a reason. 

To preserve the integrity of your SDLC process, here are 9 SDLC best practices that your engineering team can follow, and streamline development. From workflow management, to how to scope iterations accurately using data-driven insights, find it all! 

The other type of solution to such engineering challenges is harder, but goes a long way in removing those persistent SDLC blockers by inspecting, detecting, and fixing the root cause. 

For instance, is code reviews a challenge? But why are your code reviews slow? Is it because of a lack of pair programming initiatives, or the reviewer picks up the codebase too late? 

Use an engineering management platform to analyze higher PR reviews, and PR ratio, and identify optimal review workload for your team. The higher the ratio, the better your chance to understand how overburdened your devs are, or if they are compromising on their review time over other non-core tasks. 

We have also put together a list of 11 Engineering KPIs that boost engineering productivity. Download here.

3. Lack of Predictability In Software Delivery 
If you’ve spent enough time in the software industry, you would know that it’s unpredictable. The requirements may change resulting in scope creep and an exponential increase in the project budget, a sudden storm of APIs & third-party library updates can easily morph into dependency hell and bring the entire cadence to a standstill (especially when external libraries get deprecated), bugs can multiply at the rate you see zombies multiply in movies and infest your code to completely mess up the customer experience, and an invisible technical debt until yesterday could be threatening you to blow your digital infrastructure to bits if you ignore it. 

In short, one of the biggest software engineering challenges is that you’re constantly firefighting because you lack predictability. 

How To Improve Accuracy And Predictability In Software Engineering?
Minimize external dependability, especially, avoid getting locked in the cloud.
Switch to DevOps and agile software development methodologies to tackle the challenge of fluid software requirements.
Make your SDLC processes robust with adequate code review, testing, quality & performance analysis.
Infrastructure as Code (IaC) technologies, GitOps, and AIOps to automate infrastructure orchestration and management.
Infrastructure monitoring & observability tools to keep a pulse of the infrastructure health, and proactively respond to infrastructure-related software engineering challenges.
Another good solution for making the software development lifecycle (SDLC) more predictable is to equip your engineering team(s) with engineering analytics tools that improve visibility into the SDLC processes and your overall engineering health. Use a platform that comes with actionable insights to: 

Track software delivery metrics to understand your delivery status, and visualize how each variable can impact your delivery timelines. 
Run data-driven effort estimation for tasks and projects at hand. Connect each IC contribution with the overall development pipeline.  
Improve your planning accuracy by tightening your grip on scope creep, and check whether your engineering team can accommodate any more “new” requests based on effort estimation. 
4. The Problems with Development Velocity 
You need to be continuously shipping new features to the market, either to catch up with the competition or to stay ahead of them. Consumer demands keep evolving. To meet the always-increasing expectations of the consumer, a lot of things should fall in place to have a healthy and sustainable rate of software development. 

The development speed decelerates if your engineering team is affected by developer churn/attrition, inadequate code reviews, unnecessary meetings, dependency hell, infrastructure bottlenecks, scope creep, and more.

How To Speed Up Software Development, and Reduce Time To Market?
Use an engineering management platform to visualize your engineering progress, improve visibility, and make delivery trends and patterns easily identifiable: 

Use cycle time metric to visualize engineering velocity, and understand where your developers are blocked in the pipeline. 
Early detection and fixing of bugs saves time and effort later. Track defect rate by phase (e.g., development, testing, production) to pinpoint areas for improvement.
Frequent, low-risk deployments enable faster feedback and iteration. Streamline deployment processes with deployment frequency. 
5. Scalability, Security, and Performance Challenges
A software application must always be designed for scalability, security, and usability. However, different engineers have different expertise and coding styles. Some don’t comment on their code enough, and some comment excessively. Some adhere to the best coding practices, and some write programs that stink of ‘code smell’. 

In short, code quality may vary a lot if you do not have organization-level benchmarks defined for coding, if your developers have low maker time and active coding days, if your code review processes are flawed, if your software testing process is ineffective, or if the code is not well documented. Poor code quality often leads to scalability, security, or performance-related software engineering challenges.

It’s not the only culprit, inappropriate access management can lead to security vulnerabilities, poor infrastructure configuration can lead to performance and scalability challenges, and so on. It’s not about blaming a particular process, individual, or product. Scalability, security, and performance are more about practices, culture, tools, and their implementation.

How to Improve Software Scalability, Performance, and Security?
Define coding standards to write scalable code
Adopt tools like SonarQube which empowers development teams to perform code quality reviews, and static analysis of the code to detect bugs and code smells.
Implement infrastructure observability and monitoring tools for enhanced performance
Use security testing tools & platforms for enhanced security
Adhere to compliances & regulations for better security
Consider a bug bounty program to detect vulnerabilities early on.
Read more about accelerating velocity and shipping software faster. 

6. Developer Burnout, and a Struggling People Well-Being 
Developer attrition is a major software engineering challenge that many organizations are struggling with today. A high employee turnover rate could force organizations into a state where they are constrained by resource availability. 

In another survey, developers were asked about their burnout state and the reasons behind. The results were staggering. 83% of developers have reported to face burnout, and the reasons they mentioned include: high workload, inefficient processes and poorly defined project goals and targets. Other “hidden” reasons to a deteriorating developer well-being includes: 

Frequent firefighting where they spent too many hours working outside official time, and poor work-life balance 
A bad overall developer experience 
More time is spent in meetings, ad-hoc tasks over coding
Regressive sprint meetings and retro sessions
Lack of data-driven decision making to arrive at conclusions
A friction in people's health, and too many blockers in a developer’s workday results in missed opportunities, and not-so-good customer experiences. 

At the core of all of this could be a sense of not being able to achieve maximum performance with the given resources. 

How To Prevent Burnout, and Take Care Of Your Developer’s Well-Being? 
Tracking, and acting on maker time can help engineering managers to minimize distractions, reduce cognitive clutter, and improve focus time of their direct reports. It is also directly correlated to happy and productive engineers. 
Invest in DevEx (again, Hatica could be your secret tool to win this).
Invest in a culture of learning & reward (off time, recognition, and performance-based increments).
Working towards promoting alignment within and outside teams.
Fostering a culture of developer well-being (and building it into your organization’s DNA).
Deploy DevEx surveys to capture developers feelings, opinions, and comfort with the current engineering paradigm.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Answer: Unit Testing
Unit testing is the first level of testing. This testing is the most basic type of testing done by the developers before handing the software/product to the testing team.

Unit Testing Definition: Unit testing is a type of software testing in which individual units or components of the software are tested.
Primary Objective: The main objective of unit testing is to isolate each component of the software and then perform tests to illustrate that every individual component is accurately meeting the requirements and delivering the expected output.
Also explore: Software Engineer Online Courses & Certifications

Advantages of Unit Testing

Here are some of the advantages of unit testing:

Helps to catch bugs/defects earlier, which preserves both – time and money
Detects regression bugs (It is a kind of bug that is not found until and unless the software/product is released or is in production)
Helps to understand the behavior of the code 
The cost of conducting unit testing is low.
Disadvantages of Unit Testing

Here are some of the disadvantages of unit testing, such as:

Writing test cases takes time.
Unit testing is incapable of detecting all errors.
GUI code testing must be performed correctly, as it will be challenging to test the software’s graphical user interface using unit testing. 
Integration Testing
Integration testing is the second level of testing. The testers, rather than the developers, mainly conduct this testing. This testing can be performed manually or using integration testing tools, such as Selenium.

Integration Testing Definition: Integration testing is a type of software testing in which individual software components (modules) are logically integrated (combined) and tested as a group.
Primary Objective: The main objective of integration testing is to verify whether individual modules, when combined (integrated), work correctly or not as a group.
Also explore: Free Software Engineer Courses Online

Advantages of Integration Testing

Here are some of the advantages of integration testing:

Increases test coverage
Offers a higher level of reliability
Aids in the identification of integration issues between modules
Helps to ensure that the integrated components (modules) work properly before proceeding to the next level of testing: system testing
Bugs discovered at this level are more uncomplicated to resolve than those discovered at later levels of testing.
Disadvantages of Integration Testing
Here are some of the disadvantages of integration testing, such as:
•	It can be challenging to perform in comparison to system testing.
•	Testing the integration between the various connected modules takes a long time and a lot of resources.
•	It necessitates the creation of stubs and drivers, which, if not done correctly, can result in insufficient testing.
•	Lower-level modules need to be adequately tested.
•	The test output is difficult to observe.
System Testing
System testing is the third level of testing. This level of testing assists you in identifying bugs and challenges while ensuring that the software will meet all specific requirements. A specialized testing team is usually in charge of this type of testing.
System Testing Definition: System testing is software testing in which all components are tested together (as a whole) to ensure that the final product meets the specified requirements.
Primary Objective: The main objective of this level of testing is to make sure that the software/product meets specified requirements and runs as smoothly as possible in its operating environment. 
Advantages of System Testing
Here are some of the advantages of system testing:
•	Covers complete end-to-end software testing.
•	Tests both: the system software architecture and business requirements 
•	Assists in resolving post-production issues and bugs
Disadvantages of System Testing
Here are some of the disadvantages of system testing, such as:
•	Requires a lot of time as it needs to test the entire framework
•	Increases the testing cost and
•	The effort involved, as business requirements and software architecture must be considered when conducting tests.
Acceptance Testing
Acceptance testing is the last and final level of testing. This level of testing is broad in scope, ranging from simply finding spelling and cosmetic errors to discovering bugs that might produce a significant error in the software.

Acceptance Testing Definition: Acceptance testing is a type of software testing that determines whether or not the software should be released to the public.
Primary Objective: The main objective of acceptance testing is to evaluate whether the software complies with the end-user requirements and whether it is ready for deployment.
Advantages of Acceptance Testing
Here are some of the advantages of acceptance testing:
•	Identifies problems with new products before they reach users
•	Allows the clients to test the features of the software 
•	Increases satisfaction and reliability as client checks the software themself.
•	Helps the client to understand the target audience in a better way after analyzing the data gathered using acceptance testing

Disadvantages of Acceptance Testing
Here are some of the disadvantages of acceptance testing, such as:
•	Significant resources and planning are required.
•	You have no say in which test cases are used.
•	It is challenging to assess test progress.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Answer: Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs. Even though generative AI attempts to mimic humans, it requires detailed instructions to create high-quality and relevant output. In prompt engineering, you choose the most appropriate formats, phrases, words, and symbols that guide the AI to interact with your users more meaningfully. Prompt engineers use creativity plus trial and error to create a collection of input texts, so an application's generative AI works as expected.
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Answer:  here are some examples of vague prompts:
Can you give me some advice on how to be happy? What are some tips for being successful in life? (be specific – academic success, successful at sales, marketing, etc.)
How can I improve my writing skills? (You will get answers if you first ask ChatGPT about tips about writing by a famous writer like Kurt Vonnegut and then you ask ChatGPT to give examples that apply those tips – this way the AI has an authoritative source of reference.)
What are some ways to be healthier? (Tell it about your lifestyle, dietary preferences, and then ask)
Can you tell me about some interesting places to visit?  (Be specific about the country, state, city you are asking about)
The vague prompts are more difficult to answer because they are too broad and open-ended. ChatGPT will still give a coherent answer but it will not be relevant.

For example, the prompt about being happy is vague because happiness means different things to different people, and there are many factors that can contribute to it. This makes it difficult to provide specific advice without more information about the person’s individual situation and goals.

